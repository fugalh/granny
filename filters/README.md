# Synopsis
    ./forward.py [$host [$port]]
    tcpdump -l ... | ./tcpdumped.sh $event | ./forward.py
    ngrep -lt -W single ... | ./ngrepped.sh [$event] | ./forward.py

# Requirements
- [pyOSC](https://gitorious.org/pyosc)

# Details
This is a collection of useful scripts for generating granny events.

## `forward.py`
`forward.py` takes a simple ASCII representation of events on stdin,
translates them to granny OSC events, and forwards them to the requested
destination. The input format is an event name followed by an optional
timestamp, one event per line. e.g.

    GET 2013/07/03 21:32:51.492776
    GET 2013/07/03 21:32:51.777932
    GET 2013/07/03 21:32:51.786949
    GET 2013/07/03 21:32:51.787128

If the timestamp is omitted, `forward.py` marks them with the current time.

Pass it the `-h` flag for usage help.

## `tcpdumped.sh`
Given input of the form generated by `tcpdump -l -tttt ...`, generate an event
for each line of input in the format expected by `forward.py`. Example:

    tcpdump -l -tttt dst port 80 | ./tcpdumped.sh www | ./forward.py

## `ngrepped.sh`
Given input of the form generated by `ngrep -lt -W single ...`, print out
events in the ASCII protocol that `forward.py` expects on stdin. Example:

    ngrep -lt -W single dst port 80 | ./ngrepped.sh www | ./forward.py

The advantage to `ngrepped.sh` over `tcpdumped.sh` is that if the protocol
you're observing starts each packet with an ASCII command word, it can
generate different events from the same stream. (Pass it no arguments.) e.g.
the memcache text protocol.

# Your own scripts
Those two scripts are examples you can base your own scripts on. The input to
`forward.py` is very simple and easy to generate. The bigger trick is getting
line buffering (or no buffering) in all your pipeline pieces (if you want
realtime).

# Creating an ssh tunnel OSC bridge
Granny generates sound, so naturally you want to run it locally on a laptop or
workstation.

But the events you're interested in auralizing are very likely on remote
hosts. You can capture packets and do offline analysis locally, but it's more
fun to listen in realtime.

A natural approach is to use an ssh tunnel. But ssh tunnels are TCP only, and
OSC is a UDP protocol. (OSC over TCP is possible but support from libraries
and tools is spotty.)

The answer is socat. This sequence will get you up and running with an ssh
bridge on the default port (1337). It's easy to write a script to start these
commands, but it's difficult to write a script that cleans up after itself
properly so instead I'm just telling you what to run. Contributions welcome!

First, you need to run granny locally, of course:

    granny

You also need to run an instance of socat locally, which will forward traffic
incoming from the ssh tunnel to granny:

    socat tcp-listen:1337,fork udp:localhost:1337

Now let's set up that ssh tunnel:

    ssh -R1337:localhost:1337 $HOST

Then run socat on `$HOST` and tell it to forward incoming UDP traffic over the
ssh tunnel.

    socat udp-listen:1337,fork tcp:localhost:1337

If it doesn't seem to work, run granny, socat, and/or ssh with the -v
flag. And if you're still stumped, use ngrep or tcpdump to make sure packets
are showing up where you expect them. e.g.

    ngrep -qt -dlo0 port 1337

# Troubleshooting
In general, for realtime you must avoid full buffering stdout and stdin for
everything in the pipe. (Line buffering is ok, even preferable.) Examples:

    tcpdump -l
    ngrep -l
    gsed -u
    grep --line-buffered
    awk '{...; fflush()}'

These scripts are line buffered and need no special argument, but remember
that everything in the pipe needs line buffering (or no buffering).
